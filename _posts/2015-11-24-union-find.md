---
layout: post
title: 并查集（一）
category: 算法
comments: false
---

## 引子

家族关系中，如果a和b是一个家族的，b和c是一个家族的，我们知道这样a和c也是一个家族的。

有一群人，现在知道其中一些人是同一个家族的，基于这些信息，能否知道这些人中任意x和y是否是一个家族的？这些人中一共有几个家族？

## 分析

家族中的称谓地位是按辈份排下来的，每个家族中会有一个当家人，主持家族的大事，可以认为是家族的老大，称为族长。

两个人x和y，如果知道他们的族长，族长相同则是同一个家族的，否则不是。然后，这群人中，一共有几个族长，就是有几个家族。族长的特征是他的族长是他自己。

知道每个人的族长，上述的问题就很容易知道了。

但是问题中并没有告诉我们他们的族长，我们要通过已知的亲戚关系来推测。

再来思考一个问题，如何合并两个家族？

两个家族A和B，A1和B1是族长，如果A1认B1为族长，就是A1对B1说“我带领我的子民归顺于你”，这样就合并了对不对？

我们来看看，

> 原B家族中的人Bx，他的族长是B1，没有变化。

> Bx对B1说：“族长，早上好！”

> B1说：“小伙子，你好，起这么早，有出息。”

> 原A家族中的人Ax，他原来记得自己的族长是A1。

> Ax对A1说：“族长，早上好！”

> A1说：“我现在不是族长了，我们的族长是B1，你要记住。”

> Ax说：“好的，那我记住我的族长是B1了。”

所以，每当归顺家族中的人向原族长请安的时候，都知道自己换当族长了，大家都知道是B家族的人了。两个家族合并了。

对于这群人，我们一开始不知道他们之间的关系，只能先假设他们都是独立的家族，族长是自己，每个人记住自己的族长。

如果告诉我们a和b是一个家族的，那我们就根据上面的方法把a和b所在的家族合并。

构建这些关系之后，家族关系就建立起来了，这就是并查集算法。

## 算法

定义一个root数组，root[i]存放i的族长。

初始化root[i]=i，就是先假设每个人独立一个家族。

该算法是核心就是int Find(int x)函数，查找x的族长是谁，也就是“请安”，实现如下：

```c
int Find(int x){
	if(root[x]!=x){
		root[x]=Find(root[x]);//注意这里更新root[x]的值
	}
	return root[x];
}
```

## 代码

```c
#include<stdio.h>
#define N 5010
int root[N];

//初始化
void Init(int n){
	int i;
	for(i=0;i<=n;i++){
		root[i]=i;
	}
}

//查找祖先
int Find(int x){
	if(root[x]!=x){
		root[x]=Find(root[x]);
	}
	return root[x];
}

//增加一对关系
void Add(int a,int b){
	if(Find(a)!=Find(b)){
		root[Find(a)]=Find(b);
	}
}

int main(){
	int n,m,p;
	int a,b,i,cnt;
	while(scanf("%d%d%d",&n,&m,&p)!=EOF){//n(1-n)个人，m对关系，p次询问
		Init(n);
		while(m--){
			scanf("%d%d",&a,&b);//a、b有关系
			Add(a,b);
		}
		while(p--){
			scanf("%d%d",&a,&b);//询问a、b是否是有关系
			printf("%s\n",Find(a)==Find(b)?"Yes":"No");
		}
		for(cnt=0,i=1;i<=n;i++){
			if(i==Find(i)){
				cnt++;
			}
		}
		printf("家族数=%d\n",cnt);
	}
	return 0;
}
```

## 补充

这是一个分类问题，有（直接或间接）关系的元素为同一个类。

## 题目

nbu 1277 家 族

\n\n

并查集入门
